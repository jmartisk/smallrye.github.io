<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://www.smallrye.io/smallrye.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://www.smallrye.io/smallrye.github.io/" rel="alternate" type="text/html" /><updated>2020-03-04T12:22:39+00:00</updated><id>https://www.smallrye.io/smallrye.github.io/feed.xml</id><title type="html">SmallRye</title><subtitle>SmallRye is a project to share and collaborate on implementing specifications that are part of Eclipse MicroProfile.</subtitle><entry><title type="html">Fault Tolerance 4.1</title><link href="https://www.smallrye.io/smallrye.github.io/blog/fault-tolerance-4-1/" rel="alternate" type="text/html" title="Fault Tolerance 4.1" /><published>2020-02-17T12:00:00+00:00</published><updated>2020-02-17T12:00:00+00:00</updated><id>https://www.smallrye.io/smallrye.github.io/blog/fault-tolerance-4-1</id><content type="html" xml:base="https://www.smallrye.io/smallrye.github.io/blog/fault-tolerance-4-1/">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;MicroProfile Fault Tolerance 2.1 was released just 2 weeks ago, and it didn&amp;#8217;t take us long to fully implement.
Today, we announce availability of SmallRye Fault Tolerance 4.1, a compliant implementation of MicroProfile Fault Tolerance 2.1.
Here&amp;#8217;s a list of the important changes in the specification:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;@Retry.retryOn&lt;/code&gt; and &lt;code&gt;abortOn&lt;/code&gt; attributes no longer ignore &lt;code&gt;Throwable.class&lt;/code&gt;, to be consistent with other annotations that also specify exceptions.
Only &lt;code&gt;@Retry&lt;/code&gt; had a requirement that &lt;code&gt;Throwable&lt;/code&gt; is to be ignored.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Related to the previous item is that the specification now admits that throwing custom &lt;code&gt;Throwable&lt;/code&gt;s results in nonportable behavior.
Fortunately, the use cases for throwing something that isn&amp;#8217;t an &lt;code&gt;Exception&lt;/code&gt; (nor an &lt;code&gt;Error&lt;/code&gt;) should be very rare.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Also, the behavior was previously unspecified when the &lt;code&gt;@Retry.retryOn&lt;/code&gt; and &lt;code&gt;abortOn&lt;/code&gt; attributes overlap.
It is now specified that the &lt;code&gt;abortOn&lt;/code&gt; attribute &quot;wins&quot; over &lt;code&gt;retryOn&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;@CircuitBreaker.skipOn&lt;/code&gt; attribute was added, to complement the existing &lt;code&gt;failOn&lt;/code&gt; attribute.
When the attributes overlap, &lt;code&gt;skipOn&lt;/code&gt; &quot;wins&quot; over &lt;code&gt;failOn&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The &lt;code&gt;@Fallback.applyOn&lt;/code&gt; and &lt;code&gt;skipOn&lt;/code&gt; attributes were also added.
When they overlap, &lt;code&gt;skipOn&lt;/code&gt; &quot;wins&quot; over &lt;code&gt;applyOn&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;It is now specified that during the &lt;code&gt;@Asynchronous&lt;/code&gt; method execution, the CDI request context is always active.
The specification previously did not require that.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This release is also aligned with other SmallRye projects (Config and Metrics) that also recently released a new version in preparation of MicroProfile 3.3 platform release.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Enjoy the new SmallRye Fault Tolerance, it is &lt;a href=&quot;https://github.com/quarkusio/quarkus/pull/7204&quot;&gt;coming&lt;/a&gt; in the next Quarkus release!&lt;/p&gt;
&lt;/div&gt;</content><author><name>Ladislav Thon</name><email>ladicek@gmail.com</email></author><category term="announcement" /><category term="microprofile" /></entry><entry><title type="html">Fault Tolerance 4.0</title><link href="https://www.smallrye.io/smallrye.github.io/blog/fault-tolerance-4-0/" rel="alternate" type="text/html" title="Fault Tolerance 4.0" /><published>2020-01-22T08:00:00+00:00</published><updated>2020-01-22T08:00:00+00:00</updated><id>https://www.smallrye.io/smallrye.github.io/blog/fault-tolerance-4-0</id><content type="html" xml:base="https://www.smallrye.io/smallrye.github.io/blog/fault-tolerance-4-0/">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/smallrye/smallrye-fault-tolerance&quot;&gt;SmallRye Fault Tolerance&lt;/a&gt; is our implementation of &lt;a href=&quot;https://github.com/eclipse/microprofile-fault-tolerance&quot;&gt;Eclipse MicroProfile Fault Tolerance&lt;/a&gt;.
It was originally based on &lt;a href=&quot;https://github.com/Netflix/Hystrix&quot;&gt;Hystrix&lt;/a&gt;, the Netflix library for latency and fault tolerance in distributed systems.
Lately, we realized that Hystrix is not the best fit for implementing MicroProfile Fault Tolerance, because Hystrix meshes all fault tolerance concerns into one, while MicroProfile Fault Tolerance describes mostly a layered architecture.
The MicroProfile Fault Tolerance specification also requires certain features that Hystrix intentionally doesn&amp;#8217;t provide; most importantly, the ability to interrupt threads that Hystrix itself didn&amp;#8217;t create.
Last but not least, Hystrix is in maintenance mode, and hasn&amp;#8217;t been actively developed for more than a year.
When we tried to update to latest Hystrix version, we even faced breaking changes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We have been talking on and off about removing Hystrix and using our own implementation of core fault tolerance strategies, one that would be better suited as a base for implementing MicroProfile Fault Tolerance, but only a few months ago did we finally start working on it.
Thanks to heroic work of &lt;a href=&quot;https://github.com/michalszynkiewicz&quot;&gt;Micha≈Ç Szynkiewicz&lt;/a&gt;, the new implementation didn&amp;#8217;t take long to pass the entire MicroProfile Fault Tolerance TCK.
We have already released a first version of this new implementation, called 4.0.0.
Of course, that&amp;#8217;s not the end; in fact, it&amp;#8217;s just a beginning.
We should now have a better foundation to experiment with, and already have several ideas that we would like to explore and eventually propose to MicroProfile Fault Tolerance.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this article, we&amp;#8217;ll take a brief look at how the new implementation works inside, what do you need to know as an integrator, and what are our plans for the future.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;under_the_hood&quot;&gt;Under the hood&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;First, let&amp;#8217;s take a brief look at the core.
It is based on the idea of &lt;code&gt;FaultToleranceStrategy&lt;/code&gt;, which is an interface that looks like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlightjs highlight&quot;&gt;&lt;code data-lang=&quot;java&quot; class=&quot;language-java hljs&quot;&gt;interface FaultToleranceStrategy&amp;lt;V&amp;gt; {
    V apply(InvocationContext&amp;lt;V&amp;gt; ctx) throws Exception;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;InvocationContext&lt;/code&gt; is a &lt;code&gt;Callable&lt;/code&gt; that represents the method invocation guarded by this fault tolerance strategy.
The fault tolerance strategy does its work around &lt;code&gt;ctx.call()&lt;/code&gt;.
It can catch exceptions, invoke &lt;code&gt;ctx.call()&lt;/code&gt; multiple times, invoke something else, etc.
As an example, let&amp;#8217;s consider this strategy, applicable to methods that return a &lt;code&gt;String&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlightjs highlight&quot;&gt;&lt;code data-lang=&quot;java&quot; class=&quot;language-java hljs&quot;&gt;public class MyStringFallback implements FaultToleranceStrategy&amp;lt;String&amp;gt; {
    @Override
    public String apply(InvocationContext&amp;lt;String&amp;gt; ctx) {
        try {
            return ctx.call();
        } catch (Exception ignored) {
            return &quot;my string value&quot;;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is a very simple fallback mechanism, which returns a pre-defined value in case of an exception.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the SmallRye Fault Tolerance codebase, you can find implementations of all the strategies required by MicroProfile Fault Tolerance: retry, fallback, timeout, circuit breaker or bulkhead.
Asynchronous invocation, delegated to a thread pool, is of course also supported.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When multiple fault tolerance strategies are supposed to be used to guard one method, they form a chain.
Continuing with our simple example, adding the ability to chain with another strategy would look like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlightjs highlight&quot;&gt;&lt;code data-lang=&quot;java&quot; class=&quot;language-java hljs&quot;&gt;public class MyStringFallback implements FaultToleranceStrategy&amp;lt;String&amp;gt; {
    private final FaultToleranceStrategy&amp;lt;String&amp;gt; delegate;

    public MyStringFallback(FaultToleranceStrategy&amp;lt;String&amp;gt; delegate) {
        this.delegate = delegate;
    }

    @Override
    public String apply(InvocationContext&amp;lt;String&amp;gt; ctx) {
        try {
            return delegate.apply(ctx);
        } catch (Exception ignored) {
            return &quot;my string value&quot;;
        }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We see that one strategy delegates to another, passing the &lt;code&gt;InvocationContext&lt;/code&gt; along.
In fact, all the implementations in SmallRye Fault Tolerance are written like this: they expect to be used in a chain, so they take another &lt;code&gt;FaultToleranceStrategy&lt;/code&gt; to which they delegate.
But if all strategies have this form, when is &lt;code&gt;ctx.call()&lt;/code&gt; actually invoked?
Good question!
The ultimate &lt;code&gt;ctx.call()&lt;/code&gt; invocation is done by a special fault tolerance strategy which is called, well, &lt;code&gt;Invocation&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As an example which uses real MicroProfile Fault Tolerance annotations, let&amp;#8217;s consider this method:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlightjs highlight&quot;&gt;&lt;code data-lang=&quot;java&quot; class=&quot;language-java hljs&quot;&gt;@Retry(...)
@Timeout(...)
@Fallback(...)
public void doSomething() {
    ...
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The chain of fault tolerance strategies will look roughly like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlightjs highlight&quot;&gt;&lt;code class=&quot;language-none hljs&quot;&gt;Fallback(
    Retry(
        Timeout(
            Invocation(
                // ctx.call() will happen here
                // that will, in turn, invoke doSomething()
            )
        )
    )
)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The order in which the strategies are chained (or, in fact, nested) is specified by MicroProfile Fault Tolerance.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In asynchronous invocations, especially those using &lt;code&gt;CompletionStage&lt;/code&gt;, it is a bit more complex, but the core idea is the same and the intuition you gained here should still apply.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Please note that everything explained here is an implementation detail.
API stability for these interfaces and classes is &lt;em&gt;not&lt;/em&gt; guaranteed; we only mention them here to give you better understanding of the new implementation.
You will also want to understand this if you decide to contribute (pull requests are always welcome!).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;integration_concerns&quot;&gt;Integration concerns&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you integrate SmallRye Fault Tolerance to provide an implementation of MicroProfile Fault Tolerance, you should be aware of a few things.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;SmallRye Fault Tolerance creates several thread pools (&lt;code&gt;ExecutorService&lt;/code&gt;s).
One for asynchronous invocations, one for watching timeouts, and then one for each threadpool-style bulkhead.
You might want to customize how these thread pools are created.
For example, if you integrate SmallRye Fault Tolerance into a Java EE application server, you probably want these thread pools to be managed.
We provide an SPI that you can implement for this exact purpose: &lt;a href=&quot;https://github.com/smallrye/smallrye-fault-tolerance/blob/master/implementation/fault-tolerance/src/main/java/io/smallrye/faulttolerance/ExecutorFactory.java&quot;&gt;&lt;code&gt;ExecutorFactory&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Size of these thread pools can be configured using the following configuration properties:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;&lt;code&gt;io.smallrye.faulttolerance.globalThreadPoolSize&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Size of the thread pool for asynchronous invocations.
Does not include bulkhead thread pools.
Defaults to 100.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;&lt;code&gt;io.smallrye.faulttolerance.timeoutExecutorThreads&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Size of the thread pool for watching timeouts.
Defaults to 5.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Optional integration with &lt;a href=&quot;https://github.com/eclipse/microprofile-context-propagation&quot;&gt;MicroProfile Context Propagation&lt;/a&gt; is present, in a separate artifact.
Optional integration with &lt;a href=&quot;https://github.com/eclipse/microprofile-opentracing&quot;&gt;MicroProfile OpenTracing&lt;/a&gt; is also present, but it&amp;#8217;s currently built on top of the Context Propagation integration.
We&amp;#8217;re looking to potentially remove that dependency, so that OpenTracing integration is also possible if you&amp;#8217;re not yet ready to incorporate Context Propagation.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;future_outlook&quot;&gt;Future outlook&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As we mentioned above, this is not an end.
Here&amp;#8217;s a short list of what we want to look at.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;First of all, the 4.0 version implements MicroProfile Fault Tolerance 2.0.
We will of course continue implementing subsequent specification versions, starting with 2.1, which should be released soon.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Currently, MicroProfile Fault Tolerance specifies that &lt;code&gt;@Asynchronous&lt;/code&gt; invocation always means delegating to a thread pool.
We&amp;#8217;d like to investigate what would it take to support asynchronous invocation on an event loop, such as one provided by Vert.x.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We&amp;#8217;d like to add a &lt;a href=&quot;https://github.com/eclipse/microprofile-fault-tolerance/issues/475&quot;&gt;fail-fast strategy&lt;/a&gt;, tentatively called &lt;code&gt;@FailFast&lt;/code&gt;.
This is useful to prevent expensive calls when you know it doesn&amp;#8217;t make sense to do them.
One instance of this idea is the circuit breaker, which decides automatically based on rate of errors.
Here, the decision would be entirely yours.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We&amp;#8217;d also like to add &lt;a href=&quot;https://github.com/eclipse/microprofile-fault-tolerance/issues/474&quot;&gt;adaptive concurrency limiters&lt;/a&gt;, tentatively called &lt;code&gt;@AdaptiveBulkhead&lt;/code&gt;.
Bulkheads, as they exist in MicroProfile Fault Tolerance now, are defined statically.
That is, you need to know upfront what is the maximum concurrency level.
This is no longer enough in the cloud world, where services are scaled up and down dynamically.
It is possible to determine the concurrency limits dynamically, by observing the invocation latencies and error rates.
Netflix has been doing that in their &lt;a href=&quot;https://github.com/Netflix/concurrency-limits&quot;&gt;concurrency limits&lt;/a&gt; project, and we can certainly take a lot of inspiration from them.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Some of the items above are about providing a new API.
The idea is that we would prototype that API in SmallRye and if it proves worthy, we&amp;#8217;d work to specify it in MicroProfile.
For that reason, we would probably mark these prototypes as experimental API, and if they get specified in MicroProfile, we&amp;#8217;d rapidly deprecate and remove them.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There are also some implementation aspects that we&amp;#8217;d like to finetune.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The metrics collection and configuration handling code mostly comes from the old implementation, and is due for serious refactoring.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As mentioned above, each threadpool-style bulkhead currently gets a fresh thread pool.
This is quite inefficient, and can be significantly improved.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The current implementation includes a special strategy called &lt;code&gt;Tracer&lt;/code&gt;, which can be put in between any two other strategies to print useful information about when and on which thread is the subsequent strategy invoked.
This proved very useful in debugging, but using it requires manual changes and rebuild of the entire codebase.
We want to add comprehensive debug and trace logging that is always present, so that you can easily enable it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And there&amp;#8217;s a lot more, for sure.
As we said above, this is just a beginning!&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Ladislav Thon</name><email>ladicek@gmail.com</email></author><category term="announcement" /><category term="microprofile" /></entry><entry><title type="html">SmallRye Innovation for Eclipse MicroProfile</title><link href="https://www.smallrye.io/smallrye.github.io/blog/innovation/" rel="alternate" type="text/html" title="SmallRye Innovation for Eclipse MicroProfile" /><published>2019-11-27T19:00:00+00:00</published><updated>2019-11-27T19:00:00+00:00</updated><id>https://www.smallrye.io/smallrye.github.io/blog/innovation</id><content type="html" xml:base="https://www.smallrye.io/smallrye.github.io/blog/innovation/">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://smallrye.io&quot;&gt;SmallRye&lt;/a&gt; implements &lt;a href=&quot;https://microprofile.io/&quot;&gt;Eclipse MicroProfile&lt;/a&gt; specifications for use within any runtime.
Currently, SmallRye is included in &lt;a href=&quot;https://quarkus.io/&quot;&gt;Quarkus&lt;/a&gt;,
&lt;a href=&quot;https://thorntail.io&quot;&gt;Thorntail&lt;/a&gt;, &lt;a href=&quot;https://wildfly.org&quot;&gt;WildFly&lt;/a&gt;,
and the reactive implementations are part of &lt;a href=&quot;https://openliberty.io/&quot;&gt;Open Liberty&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;That&amp;#8217;s great, but that&amp;#8217;s only implementing what&amp;#8217;s been defined by a specification.
Does &lt;a href=&quot;https://smallrye.io&quot;&gt;SmallRye&lt;/a&gt; only implement the specifications &quot;&lt;em&gt;as is&lt;/em&gt;&quot;?
How do new ideas get added to &lt;a href=&quot;https://microprofile.io/&quot;&gt;MicroProfile&lt;/a&gt;,
either as new specifications or changes to an existing specification?&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Questions like these,
and others like them,
are what I hear often from those not familiar with exactly how &lt;a href=&quot;https://microprofile.io/&quot;&gt;MicroProfile&lt;/a&gt; operates.
Unlike how the JCP typically operated in the past when defining Java EE specifications,
&lt;a href=&quot;https://microprofile.io/&quot;&gt;MicroProfile&lt;/a&gt; takes a very different approach.
Bean Validation took a similar approach as &lt;a href=&quot;https://microprofile.io/&quot;&gt;MicroProfile&lt;/a&gt;.
In &lt;a href=&quot;https://microprofile.io/&quot;&gt;MicroProfile&lt;/a&gt; we define specifications based on existing implementations and usage within projects,
as it offers a greater indication that what&amp;#8217;s being proposed is useful to developers.
It&amp;#8217;s much harder to create an API from ideas and have it be useful
than to define a specification based on an already working implementation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;How does this relate to how &lt;a href=&quot;https://smallrye.io&quot;&gt;SmallRye&lt;/a&gt; develops implementations?
Since its creation &lt;a href=&quot;https://smallrye.io&quot;&gt;SmallRye&lt;/a&gt; was purposefully focused on implementing the &lt;a href=&quot;https://microprofile.io/&quot;&gt;MicroProfile&lt;/a&gt; specifications,
while seeking to improve the specifications and TCKs when issues were found.
Having reached a point where the implementations are stable and easily kept in line with modifications to existing specifications,
it frees those working on the project to shift our focus to innovation!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What type of innovation are we talking about?
In theory, it could be absolutely anything.
In practice, we&amp;#8217;re not proposing a complete free for all, as that leads to churn without results.
We have a few initiatives that are underway where we are beginning to innovate with &lt;a href=&quot;https://microprofile.io/&quot;&gt;MicroProfile&lt;/a&gt;.
We&amp;#8217;ve begun work on an entirely new implementation for Fault Tolerance, see &lt;a href=&quot;https://github.com/smallrye/smallrye-fault-tolerance/issues/102&quot;&gt;here&lt;/a&gt;,
which aims to be reactive friendly while still enabling the same functionality for imperative programming.
In &lt;a href=&quot;https://github.com/smallrye/smallrye-config&quot;&gt;SmallRye Config&lt;/a&gt; we will be investigating how to implement support for
using a pre captured configuration during the creation of later &lt;code&gt;ConfigSource&lt;/code&gt;s and &lt;code&gt;ConfigSourceProvider&lt;/code&gt;s,
allowing configuration to be used to create latter stage configuration instances.
There are also other innovations underway within the reactive sphere of &lt;a href=&quot;https://smallrye.io&quot;&gt;SmallRye&lt;/a&gt; that we intend to announce soon.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In addition to innovation within &lt;a href=&quot;https://smallrye.io&quot;&gt;SmallRye&lt;/a&gt; projects,
we&amp;#8217;re in the process of accepting the donation from the &lt;a href=&quot;https://github.com/microprofile-extensions&quot;&gt;MicroProfile Extensions&lt;/a&gt; project.
The &lt;a href=&quot;https://github.com/microprofile-extensions&quot;&gt;MicroProfile Extensions&lt;/a&gt; project includes many new &lt;code&gt;ConfigSource&lt;/code&gt; and &lt;code&gt;Converter&lt;/code&gt; types
that will be added to &lt;a href=&quot;https://smallrye.io&quot;&gt;SmallRye&lt;/a&gt;.
A big thanks to &lt;a href=&quot;https://github.com/phillip-kruger&quot;&gt;Phillip&lt;/a&gt; and &lt;a href=&quot;https://github.com/derekm&quot;&gt;Derek&lt;/a&gt; for agreeing to this and pushing it forward.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;All this innovation in &lt;a href=&quot;https://smallrye.io&quot;&gt;SmallRye&lt;/a&gt; is great,
but what does that mean for &lt;a href=&quot;https://microprofile.io/&quot;&gt;MicroProfile&lt;/a&gt; specifications?
Do they have these new innovations as well?
In the short term, no they wouldn&amp;#8217;t.
The medium to longer-term goal for any innovation created in &lt;a href=&quot;https://smallrye.io&quot;&gt;SmallRye&lt;/a&gt; is for it to be proposed to existing
or new &lt;a href=&quot;https://microprofile.io/&quot;&gt;MicroProfile&lt;/a&gt; specifications.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you&amp;#8217;d like to contribute to &lt;a href=&quot;https://smallrye.io&quot;&gt;SmallRye&lt;/a&gt; and help us deliver innovation to &lt;a href=&quot;https://microprofile.io/&quot;&gt;MicroProfile&lt;/a&gt;,
come by our &lt;a href=&quot;https://groups.google.com/d/forum/smallrye&quot;&gt;forum&lt;/a&gt; and take a look at the issues in any of the projects on &lt;a href=&quot;https://github.com/smallrye&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;</content><author><name>Ken Finnigan</name><email>ken@kenfinnigan.me</email></author><category term="announcement" /><category term="microprofile" /></entry><entry><title type="html">SmallRye on GraalVM with Quarkus!</title><link href="https://www.smallrye.io/smallrye.github.io/blog/graalvm-quarkus/" rel="alternate" type="text/html" title="SmallRye on GraalVM with Quarkus!" /><published>2019-03-07T19:00:00+00:00</published><updated>2019-03-07T19:00:00+00:00</updated><id>https://www.smallrye.io/smallrye.github.io/blog/graalvm-quarkus</id><content type="html" xml:base="https://www.smallrye.io/smallrye.github.io/blog/graalvm-quarkus/">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Marvel at SmallRye on GraalVM with Quarkus!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you haven&amp;#8217;t heard already, today &lt;a href=&quot;https://quarkus.io/&quot;&gt;Quarkus&lt;/a&gt; was released!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://quarkus.io/&quot;&gt;Quarkus&lt;/a&gt; is a new open source project for &lt;em&gt;Supersonic Subatomic Java&lt;/em&gt;!
Bringing a Kubernetes Native Java stack tailored for GraalVM and OpenJDK Hotspot,
crafted from the best of breed Java libraries and standards.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Additional details of Quarkus are on the &lt;a href=&quot;https://quarkus.io/&quot;&gt;website&lt;/a&gt;
and announcement &lt;a href=&quot;https://developers.redhat.com/blog/2019/03/07/quarkus-next-generation-kubernetes-native-java-framework&quot;&gt;blog&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;How is the announcement of &lt;a href=&quot;https://quarkus.io/&quot;&gt;Quarkus&lt;/a&gt; important for SmallRye?
&lt;a href=&quot;https://quarkus.io/&quot;&gt;Quarkus&lt;/a&gt; has extensions for each of the SmallRye implementations,
enabling a user to create a &lt;a href=&quot;https://quarkus.io/&quot;&gt;Quarkus&lt;/a&gt; application using SmallRye,
and thus &lt;a href=&quot;https://microprofile.io/&quot;&gt;Eclipse MicroProfile&lt;/a&gt;.
You can now create an application with amazingly fast boot time,
and incredibly low RSS memory (not just the heap size!),
with &lt;a href=&quot;https://microprofile.io/&quot;&gt;Eclipse MicroProfile&lt;/a&gt; APIs.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We look forward to hearing how developers enjoy the speed and memory performance in containers!&lt;/p&gt;
&lt;/div&gt;</content><author><name>Ken Finnigan</name><email>ken@kenfinnigan.me</email></author><category term="announcement" /><category term="quarkus" /></entry><entry><title type="html">SmallRye adds MicroProfile 2.2 support</title><link href="https://www.smallrye.io/smallrye.github.io/blog/microprofile-2-2/" rel="alternate" type="text/html" title="SmallRye adds MicroProfile 2.2 support" /><published>2019-03-06T19:00:00+00:00</published><updated>2019-03-06T19:00:00+00:00</updated><id>https://www.smallrye.io/smallrye.github.io/blog/microprofile-2-2</id><content type="html" xml:base="https://www.smallrye.io/smallrye.github.io/blog/microprofile-2-2/">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;SmallRye now has all implementations passing the TCKs for MicroProfile 2.2 specifications!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The full list of completed implementations:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Config 1.3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fault Tolerance 2.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Health 1.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JWT 1.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Metrics 1.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenAPI 1.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenTracing 1.3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REST Client 1.2&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Check out the &lt;a href=&quot;/projects&quot;&gt;Projects page&lt;/a&gt; for all the details!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Thanks to everyone from the community that enabled us to implement the specification so fast!&lt;/p&gt;
&lt;/div&gt;</content><author><name>Ken Finnigan</name><email>ken@kenfinnigan.me</email></author><category term="announcement" /><category term="microprofile" /></entry><entry><title type="html">SmallRye adds MicroProfile 1.3 support</title><link href="https://www.smallrye.io/smallrye.github.io/blog/microprofile-1-3/" rel="alternate" type="text/html" title="SmallRye adds MicroProfile 1.3 support" /><published>2018-09-07T19:00:00+00:00</published><updated>2018-09-07T19:00:00+00:00</updated><id>https://www.smallrye.io/smallrye.github.io/blog/microprofile-1-3</id><content type="html" xml:base="https://www.smallrye.io/smallrye.github.io/blog/microprofile-1-3/">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;SmallRye now has all implementations passing the TCKs for MicroProfile 1.3 specifications!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The full list of completed implementations:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Config 1.3&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fault Tolerance 1.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Health 1.0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JWT 1.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Metrics 1.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenAPI 1.0.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenTracing 1.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;REST Client 1.0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Check out the &lt;a href=&quot;/projects&quot;&gt;Projects page&lt;/a&gt; for all the details!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One important to note is that some of these implementations are already compliant
MicroProfile 1.4! The team is in the process of implementing updates to the
remaining specifications to reach full MicroProfile 1.4 compliance.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Why not join the community and help us out!&lt;/p&gt;
&lt;/div&gt;</content><author><name>Ken Finnigan</name><email>ken@kenfinnigan.me</email></author><category term="announcement" /><category term="microprofile" /></entry><entry><title type="html">Welcome to SmallRye</title><link href="https://www.smallrye.io/smallrye.github.io/blog/welcome/" rel="alternate" type="text/html" title="Welcome to SmallRye" /><published>2018-06-28T19:00:00+00:00</published><updated>2018-06-28T19:00:00+00:00</updated><id>https://www.smallrye.io/smallrye.github.io/blog/welcome</id><content type="html" xml:base="https://www.smallrye.io/smallrye.github.io/blog/welcome/">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;SmallRye welcomes you to our new community for developing shared
implementations of Eclipse MicroProfile specifications!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Right now we&amp;#8217;re still in the process of seeding the initial versions of
the repositories for each Eclipse MicroProfile specification implementation.
As they&amp;#8217;re released we will be updating the overview page and creating
a page specific to each implementation on the website.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Currently we have released the following implementations:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Config&lt;/strong&gt;, &lt;strong&gt;REST Client&lt;/strong&gt;, &lt;strong&gt;Open API&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The plan is to have the remainder migrated and released within the next couple of weeks.&lt;/p&gt;
&lt;/div&gt;</content><author><name>Ken Finnigan</name><email>ken@kenfinnigan.me</email></author><category term="announcement" /></entry></feed>